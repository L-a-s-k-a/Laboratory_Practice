#include "../Inc/init.h"

void GPIO_Init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN | RCC_AHB1ENR_GPIOBEN;
    //set LED 1 (pin0)
    SET_BIT(GPIOB->MODER, GPIO_MODER_MODE0_0); 
    CLEAR_BIT(GPIOB->OTYPER, GPIO_OTYPER_OT0);
    SET_BIT(GPIOB->OSPEEDR, GPIO_OSPEEDER_OSPEEDR0_0);
    CLEAR_BIT(GPIOB->PUPDR, GPIO_PUPDR_PUPDR0_0);
    SET_BIT(GPIOB->BSRR, GPIO_BSRR_BR0);
    //set LED 2 (pin14)
    SET_BIT(GPIOB->MODER, GPIO_MODER_MODE14_0); 
    CLEAR_BIT(GPIOB->OTYPER, GPIO_OTYPER_OT14);
    SET_BIT(GPIOB->OSPEEDR, GPIO_OSPEEDER_OSPEEDR14_0);
    CLEAR_BIT(GPIOB->PUPDR, GPIO_PUPDR_PUPDR14_0);
    SET_BIT(GPIOB->BSRR, GPIO_BSRR_BR14);
    //set LED 3 (pin7)
    SET_BIT(GPIOB->MODER, GPIO_MODER_MODE7_0); 
    CLEAR_BIT(GPIOB->OTYPER, GPIO_OTYPER_OT7);
    SET_BIT(GPIOB->OSPEEDR, GPIO_OSPEEDER_OSPEEDR7_0);
    CLEAR_BIT(GPIOB->PUPDR, GPIO_PUPDR_PUPDR7_0);
    SET_BIT(GPIOB->BSRR, GPIO_BSRR_BR7);
    //set LED 4 (pin8)
    SET_BIT(GPIOB->MODER, GPIO_MODER_MODE8_0); 
    CLEAR_BIT(GPIOB->OTYPER, GPIO_OTYPER_OT8);
    SET_BIT(GPIOB->OSPEEDR, GPIO_OSPEEDER_OSPEEDR8_0);
    CLEAR_BIT(GPIOB->PUPDR, GPIO_PUPDR_PUPDR8_0);
    SET_BIT(GPIOB->BSRR, GPIO_BSRR_BR8);
    SET_BIT(GPIOB->MODER, GPIO_MODER_MODE8_0); 
     //set LED 5 (pin9)
     SET_BIT(GPIOB->MODER, GPIO_MODER_MODE9_0);
    CLEAR_BIT(GPIOB->OTYPER, GPIO_OTYPER_OT9);
    SET_BIT(GPIOB->OSPEEDR, GPIO_OSPEEDER_OSPEEDR9_0);
    CLEAR_BIT(GPIOB->PUPDR, GPIO_PUPDR_PUPDR9_0);
    SET_BIT(GPIOB->BSRR, GPIO_BSRR_BR9);
    //set LED 6 (pin10)
     SET_BIT(GPIOB->MODER, GPIO_MODER_MODE10_0);
    CLEAR_BIT(GPIOB->OTYPER, GPIO_OTYPER_OT10);
    SET_BIT(GPIOB->OSPEEDR, GPIO_OSPEEDER_OSPEEDR10_0);
    CLEAR_BIT(GPIOB->PUPDR, GPIO_PUPDR_PUPDR10_0);
    SET_BIT(GPIOB->BSRR, GPIO_BSRR_BR10);

    
}

void RCC_Init(void){
    // 清除所有参与配置的位
    MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, 0x80U);
    CLEAR_REG(RCC->CFGR);
    while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET); // 等待系统时钟切换完成
    CLEAR_BIT(RCC->CR, RCC_CR_PLLON); 
    while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET); // 等待 PLL 关闭
    CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON); 
    while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET); // 等待外部晶振关闭
    CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);

    /* 配置主 RCC 寄存器 */
    SET_BIT(RCC->CR, RCC_CR_HSEON); // 启动外部晶振
    while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET); // 等待外部晶振启动
    CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP); // 如果有外部时钟旁路设置，清除该设置
    SET_BIT(RCC->CR, RCC_CR_CSSON); // 启动时钟安全系统（Clock security system）
    
    CLEAR_REG(RCC->PLLCFGR);
    SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC_HSE); // 设置 PLL 时钟源为外部晶振
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLM, RCC_PLLCFGR_PLLM_2); // 设置 PLL 输入频率的预分频器为 4
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_Msk, RCC_PLLCFGR_PLLN_2 | RCC_PLLCFGR_PLLN_4 | RCC_PLLCFGR_PLLN_5 | RCC_PLLCFGR_PLLN_7); // 设置 PLL 频率倍增，倍频因子为 180
    CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP_Msk); // 配置 PLL 输出频率的预分频器
    SET_BIT(RCC->CR, RCC_CR_PLLON); // 启动 PLL 
    while(READ_BIT(RCC->CR, RCC_CR_PLLRDY)); // 等待 PLL 启动完成
    
    // 配置 RCC_CFGR 寄存器
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL); // 选择 PLL 作为系统时钟
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_DIV1); // 设置 AHB 时钟无预分频
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV4); // 设置 APB1 时钟预分频为 4
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV2); // 设置 APB2 时钟预分频为 2
    MODIFY_REG(RCC->CFGR, RCC_CFGR_MCO2PRE, RCC_CFGR_MCO2PRE_Msk); // 设置 MCO2 输出预分频为 5
    CLEAR_BIT(RCC->CFGR, RCC_CFGR_MCO2); // 配置 MCO2 输出为系统时钟
    // 设置 FLASH 存储器的延迟为 6 个 CPU 时钟周期
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_5WS); 
}

void ITR_Init(void){ 
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN); // 启用 SYSCFG 外设时钟
    NVIC_SetPriorityGrouping(0); // 设置中断优先级分组方式（无子优先级）
    MODIFY_REG(SYSCFG->EXTICR[3], SYSCFG_EXTICR4_EXTI13_Msk, SYSCFG_EXTICR4_EXTI13_PC); // 配置外部中断线路 EXTI13 映射到 PC13 引脚
    SET_BIT(EXTI->IMR, EXTI_IMR_MR13); // 使能 EXTI13 中断
    SET_BIT(EXTI->RTSR, EXTI_RTSR_TR13); // 配置 EXTI13 线路触发方式为上升沿触发
    SET_BIT(EXTI->FTSR, EXTI_FTSR_TR13); // 配置 EXTI13 线路触发方式为下降沿触发
    NVIC_SetPriority(EXTI15_10_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 2, 0)); // 设置 EXTI15_10 中断优先级为 2
    NVIC_EnableIRQ(EXTI15_10_IRQn); // 使能 EXTI15_10 中断向量
    MODIFY_REG(SYSCFG->EXTICR[1], SYSCFG_EXTICR2_EXTI6_Msk, SYSCFG_EXTICR2_EXTI6_PC); // 配置外部中断线路 EXTI6 映射到 PC6 引脚
    SET_BIT(EXTI->IMR, EXTI_IMR_MR6); // 使能 EXTI6 中断
    SET_BIT(EXTI->RTSR, EXTI_RTSR_TR6); // 配置 EXTI6 线路触发方式为上升沿触发
    SET_BIT(EXTI->FTSR, EXTI_FTSR_TR6); // 配置 EXTI6 线路触发方式为下降沿触发
    NVIC_SetPriority(EXTI9_5_IRQn , NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 2, 0)); // 设置 EXTI9_5 中断优先级为 2
    NVIC_EnableIRQ(EXTI9_5_IRQn); // 使能 EXTI9_5 中断向量
} 

void SysTick_Init(void){ 
    CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_ENABLE_Msk); // 先禁用计数器
    SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk); // 使能 SysTick 中断
    SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk); // 设置时钟源为 AHB 时钟，无分频
    MODIFY_REG(SysTick->LOAD, SysTick_LOAD_RELOAD_Msk, SYSTLOAD << SysTick_LOAD_RELOAD_Pos); // 设置 SysTick 的重载值，使其以 1kHz 的频率计数
    MODIFY_REG(SysTick->VAL, SysTick_VAL_CURRENT_Msk, SYSTLOAD << SysTick_VAL_CURRENT_Pos); // 设置 SysTick 初始值
    SET_BIT(SysTick->CTRL, SysTick_CTRL_ENABLE_Msk); // 启用 SysTick 计数器
} 
